{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useEffect, useRef, useCallback } from 'react';\nconst ObjectDetection = ({\n  videoRef,\n  onEvent\n}) => {\n  _s();\n  const modelRef = useRef(null);\n  const detectionIntervalRef = useRef(null);\n\n  // Simple object detection using basic computer vision principles\n  // This is a fallback implementation since we can't import TensorFlow.js in this environment\n  const detectObjects = useCallback(video => {\n    if (!video || video.videoWidth === 0 || video.videoHeight === 0) {\n      return [];\n    }\n\n    // Create a temporary canvas for analysis\n    const canvas = document.createElement('canvas');\n    const ctx = canvas.getContext('2d');\n    canvas.width = video.videoWidth;\n    canvas.height = video.videoHeight;\n\n    // Draw video frame to canvas\n    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);\n\n    // Get image data\n    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n    const data = imageData.data;\n    const detectedObjects = [];\n\n    // Simple object detection based on shape and color patterns\n    // This is a very basic implementation for demonstration purposes\n\n    // Phone detection: Look for rectangular dark objects (common phone shape)\n    let darkRectangularRegions = 0;\n    const blockSize = 20;\n    for (let y = 0; y < canvas.height - blockSize; y += blockSize) {\n      for (let x = 0; x < canvas.width - blockSize; x += blockSize) {\n        let avgBrightness = 0;\n        let edgeCount = 0;\n\n        // Analyze block\n        for (let by = y; by < y + blockSize; by += 2) {\n          for (let bx = x; bx < x + blockSize; bx += 2) {\n            const index = (by * canvas.width + bx) * 4;\n            const r = data[index];\n            const g = data[index + 1];\n            const b = data[index + 2];\n            const brightness = (r + g + b) / 3;\n            avgBrightness += brightness;\n\n            // Edge detection (simple)\n            if (bx < x + blockSize - 1 && by < y + blockSize - 1) {\n              const nextIndex = (by * canvas.width + bx + 1) * 4;\n              const nextR = data[nextIndex];\n              const nextG = data[nextIndex + 1];\n              const nextB = data[nextIndex + 2];\n              const nextBrightness = (nextR + nextG + nextB) / 3;\n              if (Math.abs(brightness - nextBrightness) > 50) {\n                edgeCount++;\n              }\n            }\n          }\n        }\n        avgBrightness /= blockSize / 2 * (blockSize / 2);\n\n        // Phone-like object: Dark, rectangular, with defined edges\n        if (avgBrightness < 80 && edgeCount > 5 && edgeCount < 20) {\n          darkRectangularRegions++;\n        }\n      }\n    }\n\n    // Book detection: Look for white/bright rectangular regions\n    let brightRectangularRegions = 0;\n    for (let y = 0; y < canvas.height - blockSize * 2; y += blockSize) {\n      for (let x = 0; x < canvas.width - blockSize * 2; x += blockSize) {\n        let avgBrightness = 0;\n        let whitePixels = 0;\n        for (let by = y; by < y + blockSize * 2; by += 3) {\n          for (let bx = x; bx < x + blockSize * 2; bx += 3) {\n            const index = (by * canvas.width + bx) * 4;\n            const r = data[index];\n            const g = data[index + 2];\n            const b = data[index + 2];\n            const brightness = (r + g + b) / 3;\n            avgBrightness += brightness;\n            if (brightness > 200 && Math.abs(r - g) < 30 && Math.abs(g - b) < 30) {\n              whitePixels++;\n            }\n          }\n        }\n        const totalPixels = blockSize * 2 / 3 * (blockSize * 2 / 3);\n        avgBrightness /= totalPixels;\n\n        // Book-like object: Bright, rectangular, lots of white pixels\n        if (avgBrightness > 180 && whitePixels / totalPixels > 0.6) {\n          brightRectangularRegions++;\n        }\n      }\n    }\n\n    // Laptop detection: Look for dark regions with bright screen areas\n    let laptopLikeRegions = 0;\n\n    // Check for laptop screen pattern (bright rectangle with dark borders)\n    for (let y = blockSize; y < canvas.height - blockSize * 3; y += blockSize * 2) {\n      for (let x = blockSize; x < canvas.width - blockSize * 3; x += blockSize * 2) {\n        let screenBrightness = 0;\n        let borderDarkness = 0;\n        let screenPixels = 0;\n        let borderPixels = 0;\n\n        // Check screen area (center)\n        for (let sy = y + blockSize; sy < y + blockSize * 2; sy += 2) {\n          for (let sx = x + blockSize; sx < x + blockSize * 2; sx += 2) {\n            const index = (sy * canvas.width + sx) * 4;\n            const r = data[index];\n            const g = data[index + 1];\n            const b = data[index + 2];\n            screenBrightness += (r + g + b) / 3;\n            screenPixels++;\n          }\n        }\n\n        // Check border area\n        for (let by = y; by < y + blockSize * 3; by += 2) {\n          for (let bx = x; bx < x + blockSize * 3; bx += 2) {\n            if (by < y + blockSize || by >= y + blockSize * 2 || bx < x + blockSize || bx >= x + blockSize * 2) {\n              const index = (by * canvas.width + bx) * 4;\n              const r = data[index];\n              const g = data[index + 1];\n              const b = data[index + 2];\n              borderDarkness += (r + g + b) / 3;\n              borderPixels++;\n            }\n          }\n        }\n        screenBrightness /= screenPixels;\n        borderDarkness /= borderPixels;\n\n        // Laptop pattern: Bright screen, dark border\n        if (screenBrightness > 120 && borderDarkness < 80 && screenBrightness - borderDarkness > 60) {\n          laptopLikeRegions++;\n        }\n      }\n    }\n\n    // Add detected objects based on our analysis\n    if (darkRectangularRegions > 3) {\n      detectedObjects.push({\n        class: 'cell phone',\n        confidence: Math.min(0.7 + (darkRectangularRegions - 3) * 0.1, 0.95)\n      });\n    }\n    if (brightRectangularRegions > 2) {\n      detectedObjects.push({\n        class: 'book',\n        confidence: Math.min(0.6 + (brightRectangularRegions - 2) * 0.15, 0.9)\n      });\n    }\n    if (laptopLikeRegions > 1) {\n      detectedObjects.push({\n        class: 'laptop',\n        confidence: Math.min(0.65 + (laptopLikeRegions - 1) * 0.15, 0.88)\n      });\n    }\n    return detectedObjects;\n  }, []);\n  const performObjectDetection = useCallback(async () => {\n    if (!videoRef.current) return;\n    try {\n      const predictions = detectObjects(videoRef.current);\n\n      // Filter for unauthorized objects\n      const unauthorizedObjects = predictions.filter(prediction => ['cell phone', 'book', 'laptop'].includes(prediction.class) && prediction.confidence > 0.5);\n      unauthorizedObjects.forEach(obj => {\n        const message = `Unauthorized object detected: ${obj.class} (confidence: ${(obj.confidence * 100).toFixed(1)}%)`;\n        onEvent(message, 'suspicious');\n      });\n    } catch (error) {\n      console.error('Object detection error:', error);\n      onEvent('Object detection error: ' + error.message, 'error');\n    }\n  }, [detectObjects, onEvent]);\n  useEffect(() => {\n    // Initialize object detection\n    onEvent('Object detection system initialized', 'info');\n\n    // Start detection interval (every 3 seconds)\n    detectionIntervalRef.current = setInterval(() => {\n      performObjectDetection();\n    }, 3000);\n    return () => {\n      if (detectionIntervalRef.current) {\n        clearInterval(detectionIntervalRef.current);\n      }\n      onEvent('Object detection monitoring stopped', 'info');\n    };\n  }, [performObjectDetection, onEvent]);\n  return null; // This component doesn't render anything visible\n};\n_s(ObjectDetection, \"6Wr9tseWoZZdC1CTvMBKEPgO+M0=\");\n_c = ObjectDetection;\nexport default ObjectDetection;\nvar _c;\n$RefreshReg$(_c, \"ObjectDetection\");","map":{"version":3,"names":["useEffect","useRef","useCallback","ObjectDetection","videoRef","onEvent","_s","modelRef","detectionIntervalRef","detectObjects","video","videoWidth","videoHeight","canvas","document","createElement","ctx","getContext","width","height","drawImage","imageData","getImageData","data","detectedObjects","darkRectangularRegions","blockSize","y","x","avgBrightness","edgeCount","by","bx","index","r","g","b","brightness","nextIndex","nextR","nextG","nextB","nextBrightness","Math","abs","brightRectangularRegions","whitePixels","totalPixels","laptopLikeRegions","screenBrightness","borderDarkness","screenPixels","borderPixels","sy","sx","push","class","confidence","min","performObjectDetection","current","predictions","unauthorizedObjects","filter","prediction","includes","forEach","obj","message","toFixed","error","console","setInterval","clearInterval","_c","$RefreshReg$"],"sources":["C:/Users/nikhi/OneDrive/Desktop/Tutedude SDE Assignment/interview-proctoring-system/src/components/ObjectDetection.js"],"sourcesContent":["import { useEffect, useRef, useCallback } from 'react';\r\n\r\nconst ObjectDetection = ({ videoRef, onEvent }) => {\r\n  const modelRef = useRef(null);\r\n  const detectionIntervalRef = useRef(null);\r\n\r\n  // Simple object detection using basic computer vision principles\r\n  // This is a fallback implementation since we can't import TensorFlow.js in this environment\r\n  const detectObjects = useCallback((video) => {\r\n    if (!video || video.videoWidth === 0 || video.videoHeight === 0) {\r\n      return [];\r\n    }\r\n\r\n    // Create a temporary canvas for analysis\r\n    const canvas = document.createElement('canvas');\r\n    const ctx = canvas.getContext('2d');\r\n    canvas.width = video.videoWidth;\r\n    canvas.height = video.videoHeight;\r\n    \r\n    // Draw video frame to canvas\r\n    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);\r\n    \r\n    // Get image data\r\n    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\r\n    const data = imageData.data;\r\n    \r\n    const detectedObjects = [];\r\n    \r\n    // Simple object detection based on shape and color patterns\r\n    // This is a very basic implementation for demonstration purposes\r\n    \r\n    // Phone detection: Look for rectangular dark objects (common phone shape)\r\n    let darkRectangularRegions = 0;\r\n    const blockSize = 20;\r\n    \r\n    for (let y = 0; y < canvas.height - blockSize; y += blockSize) {\r\n      for (let x = 0; x < canvas.width - blockSize; x += blockSize) {\r\n        let avgBrightness = 0;\r\n        let edgeCount = 0;\r\n        \r\n        // Analyze block\r\n        for (let by = y; by < y + blockSize; by += 2) {\r\n          for (let bx = x; bx < x + blockSize; bx += 2) {\r\n            const index = (by * canvas.width + bx) * 4;\r\n            const r = data[index];\r\n            const g = data[index + 1];\r\n            const b = data[index + 2];\r\n            \r\n            const brightness = (r + g + b) / 3;\r\n            avgBrightness += brightness;\r\n            \r\n            // Edge detection (simple)\r\n            if (bx < x + blockSize - 1 && by < y + blockSize - 1) {\r\n              const nextIndex = ((by * canvas.width + bx + 1) * 4);\r\n              const nextR = data[nextIndex];\r\n              const nextG = data[nextIndex + 1];\r\n              const nextB = data[nextIndex + 2];\r\n              const nextBrightness = (nextR + nextG + nextB) / 3;\r\n              \r\n              if (Math.abs(brightness - nextBrightness) > 50) {\r\n                edgeCount++;\r\n              }\r\n            }\r\n          }\r\n        }\r\n        \r\n        avgBrightness /= (blockSize / 2) * (blockSize / 2);\r\n        \r\n        // Phone-like object: Dark, rectangular, with defined edges\r\n        if (avgBrightness < 80 && edgeCount > 5 && edgeCount < 20) {\r\n          darkRectangularRegions++;\r\n        }\r\n      }\r\n    }\r\n    \r\n    // Book detection: Look for white/bright rectangular regions\r\n    let brightRectangularRegions = 0;\r\n    \r\n    for (let y = 0; y < canvas.height - blockSize * 2; y += blockSize) {\r\n      for (let x = 0; x < canvas.width - blockSize * 2; x += blockSize) {\r\n        let avgBrightness = 0;\r\n        let whitePixels = 0;\r\n        \r\n        for (let by = y; by < y + blockSize * 2; by += 3) {\r\n          for (let bx = x; bx < x + blockSize * 2; bx += 3) {\r\n            const index = (by * canvas.width + bx) * 4;\r\n            const r = data[index];\r\n            const g = data[index + 2];\r\n            const b = data[index + 2];\r\n            \r\n            const brightness = (r + g + b) / 3;\r\n            avgBrightness += brightness;\r\n            \r\n            if (brightness > 200 && Math.abs(r - g) < 30 && Math.abs(g - b) < 30) {\r\n              whitePixels++;\r\n            }\r\n          }\r\n        }\r\n        \r\n        const totalPixels = ((blockSize * 2) / 3) * ((blockSize * 2) / 3);\r\n        avgBrightness /= totalPixels;\r\n        \r\n        // Book-like object: Bright, rectangular, lots of white pixels\r\n        if (avgBrightness > 180 && whitePixels / totalPixels > 0.6) {\r\n          brightRectangularRegions++;\r\n        }\r\n      }\r\n    }\r\n    \r\n    // Laptop detection: Look for dark regions with bright screen areas\r\n    let laptopLikeRegions = 0;\r\n    \r\n    // Check for laptop screen pattern (bright rectangle with dark borders)\r\n    for (let y = blockSize; y < canvas.height - blockSize * 3; y += blockSize * 2) {\r\n      for (let x = blockSize; x < canvas.width - blockSize * 3; x += blockSize * 2) {\r\n        let screenBrightness = 0;\r\n        let borderDarkness = 0;\r\n        let screenPixels = 0;\r\n        let borderPixels = 0;\r\n        \r\n        // Check screen area (center)\r\n        for (let sy = y + blockSize; sy < y + blockSize * 2; sy += 2) {\r\n          for (let sx = x + blockSize; sx < x + blockSize * 2; sx += 2) {\r\n            const index = (sy * canvas.width + sx) * 4;\r\n            const r = data[index];\r\n            const g = data[index + 1];\r\n            const b = data[index + 2];\r\n            screenBrightness += (r + g + b) / 3;\r\n            screenPixels++;\r\n          }\r\n        }\r\n        \r\n        // Check border area\r\n        for (let by = y; by < y + blockSize * 3; by += 2) {\r\n          for (let bx = x; bx < x + blockSize * 3; bx += 2) {\r\n            if ((by < y + blockSize || by >= y + blockSize * 2) || \r\n                (bx < x + blockSize || bx >= x + blockSize * 2)) {\r\n              const index = (by * canvas.width + bx) * 4;\r\n              const r = data[index];\r\n              const g = data[index + 1];\r\n              const b = data[index + 2];\r\n              borderDarkness += (r + g + b) / 3;\r\n              borderPixels++;\r\n            }\r\n          }\r\n        }\r\n        \r\n        screenBrightness /= screenPixels;\r\n        borderDarkness /= borderPixels;\r\n        \r\n        // Laptop pattern: Bright screen, dark border\r\n        if (screenBrightness > 120 && borderDarkness < 80 && \r\n            screenBrightness - borderDarkness > 60) {\r\n          laptopLikeRegions++;\r\n        }\r\n      }\r\n    }\r\n    \r\n    // Add detected objects based on our analysis\r\n    if (darkRectangularRegions > 3) {\r\n      detectedObjects.push({\r\n        class: 'cell phone',\r\n        confidence: Math.min(0.7 + (darkRectangularRegions - 3) * 0.1, 0.95)\r\n      });\r\n    }\r\n    \r\n    if (brightRectangularRegions > 2) {\r\n      detectedObjects.push({\r\n        class: 'book',\r\n        confidence: Math.min(0.6 + (brightRectangularRegions - 2) * 0.15, 0.9)\r\n      });\r\n    }\r\n    \r\n    if (laptopLikeRegions > 1) {\r\n      detectedObjects.push({\r\n        class: 'laptop',\r\n        confidence: Math.min(0.65 + (laptopLikeRegions - 1) * 0.15, 0.88)\r\n      });\r\n    }\r\n    \r\n    return detectedObjects;\r\n  }, []);\r\n\r\n  const performObjectDetection = useCallback(async () => {\r\n    if (!videoRef.current) return;\r\n\r\n    try {\r\n      const predictions = detectObjects(videoRef.current);\r\n      \r\n      // Filter for unauthorized objects\r\n      const unauthorizedObjects = predictions.filter(prediction => \r\n        ['cell phone', 'book', 'laptop'].includes(prediction.class) && \r\n        prediction.confidence > 0.5\r\n      );\r\n\r\n      unauthorizedObjects.forEach(obj => {\r\n        const message = `Unauthorized object detected: ${obj.class} (confidence: ${(obj.confidence * 100).toFixed(1)}%)`;\r\n        onEvent(message, 'suspicious');\r\n      });\r\n\r\n    } catch (error) {\r\n      console.error('Object detection error:', error);\r\n      onEvent('Object detection error: ' + error.message, 'error');\r\n    }\r\n  }, [detectObjects, onEvent]);\r\n\r\n  useEffect(() => {\r\n    // Initialize object detection\r\n    onEvent('Object detection system initialized', 'info');\r\n    \r\n    // Start detection interval (every 3 seconds)\r\n    detectionIntervalRef.current = setInterval(() => {\r\n      performObjectDetection();\r\n    }, 3000);\r\n\r\n    return () => {\r\n      if (detectionIntervalRef.current) {\r\n        clearInterval(detectionIntervalRef.current);\r\n      }\r\n      onEvent('Object detection monitoring stopped', 'info');\r\n    };\r\n  }, [performObjectDetection, onEvent]);\r\n\r\n  return null; // This component doesn't render anything visible\r\n};\r\n\r\nexport default ObjectDetection;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}