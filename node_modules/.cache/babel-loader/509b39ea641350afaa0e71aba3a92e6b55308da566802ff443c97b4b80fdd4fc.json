{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useEffect, useRef, useCallback } from 'react';\nconst FaceDetection = ({\n  videoRef,\n  canvasRef,\n  onEvent\n}) => {\n  _s();\n  const faceDetectionRef = useRef(null);\n  const lastFaceDetectedRef = useRef(Date.now());\n  const lastLookingAwayRef = useRef(Date.now());\n  const noFaceTimerRef = useRef(null);\n  const lookingAwayTimerRef = useRef(null);\n\n  // Simple face detection fallback using basic computer vision principles\n  const detectFaces = useCallback((video, canvas) => {\n    if (!video || !canvas || video.videoWidth === 0 || video.videoHeight === 0) {\n      return {\n        faces: [],\n        lookingAway: false\n      };\n    }\n    const ctx = canvas.getContext('2d');\n    canvas.width = video.videoWidth;\n    canvas.height = video.videoHeight;\n\n    // Draw video frame to canvas\n    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);\n\n    // Get image data\n    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n    const data = imageData.data;\n    const faces = [];\n    const gridSize = 32; // Divide image into 32x32 pixel blocks\n    const skinRegions = [];\n\n    // Scan the image in blocks to find skin-colored regions\n    for (let blockY = 0; blockY < canvas.height - gridSize; blockY += gridSize) {\n      for (let blockX = 0; blockX < canvas.width - gridSize; blockX += gridSize) {\n        let skinPixels = 0;\n        let totalPixels = 0;\n        let avgBrightness = 0;\n\n        // Check each pixel in this block\n        for (let y = blockY; y < blockY + gridSize; y += 2) {\n          for (let x = blockX; x < blockX + gridSize; x += 2) {\n            const index = (y * canvas.width + x) * 4;\n            const r = data[index];\n            const g = data[index + 1];\n            const b = data[index + 2];\n            const brightness = (r + g + b) / 3;\n            avgBrightness += brightness;\n\n            // Improved skin color detection\n            if (r > 95 && g > 40 && b > 20 && Math.max(r, g, b) - Math.min(r, g, b) > 15 && Math.abs(r - g) > 15 && r > g && r > b && r < 255 && g < 255 && b < 255) {\n              // Avoid oversaturated pixels\n              skinPixels++;\n            }\n            totalPixels++;\n          }\n        }\n        const skinRatio = skinPixels / totalPixels;\n        avgBrightness /= totalPixels;\n\n        // If this block has significant skin content, it might be a face region\n        if (skinRatio > 0.15 && avgBrightness > 60 && avgBrightness < 200) {\n          skinRegions.push({\n            x: blockX,\n            y: blockY,\n            skinRatio: skinRatio,\n            brightness: avgBrightness\n          });\n        }\n      }\n    }\n\n    // Group nearby skin regions to form face candidates\n    const faceRegions = [];\n    const used = new Set();\n    for (let i = 0; i < skinRegions.length; i++) {\n      if (used.has(i)) continue;\n      const region = skinRegions[i];\n      const group = [region];\n      used.add(i);\n\n      // Find nearby regions\n      for (let j = i + 1; j < skinRegions.length; j++) {\n        if (used.has(j)) continue;\n        const other = skinRegions[j];\n        const distance = Math.sqrt(Math.pow(region.x - other.x, 2) + Math.pow(region.y - other.y, 2));\n\n        // If regions are close enough, group them\n        if (distance < gridSize * 3) {\n          group.push(other);\n          used.add(j);\n        }\n      }\n\n      // If group has enough regions, consider it a face\n      if (group.length >= 3) {\n        const minX = Math.min(...group.map(r => r.x));\n        const maxX = Math.max(...group.map(r => r.x)) + gridSize;\n        const minY = Math.min(...group.map(r => r.y));\n        const maxY = Math.max(...group.map(r => r.y)) + gridSize;\n        const avgSkinRatio = group.reduce((sum, r) => sum + r.skinRatio, 0) / group.length;\n        faceRegions.push({\n          x: minX,\n          y: minY,\n          width: maxX - minX,\n          height: maxY - minY,\n          confidence: avgSkinRatio,\n          regions: group.length\n        });\n      }\n    }\n\n    // Filter out overlapping regions (keep the one with higher confidence)\n    const filteredFaces = [];\n    for (let i = 0; i < faceRegions.length; i++) {\n      const face1 = faceRegions[i];\n      let keep = true;\n      for (let j = 0; j < faceRegions.length; j++) {\n        if (i === j) continue;\n        const face2 = faceRegions[j];\n\n        // Check for significant overlap\n        const overlapX = Math.max(0, Math.min(face1.x + face1.width, face2.x + face2.width) - Math.max(face1.x, face2.x));\n        const overlapY = Math.max(0, Math.min(face1.y + face1.height, face2.y + face2.height) - Math.max(face1.y, face2.y));\n        const overlapArea = overlapX * overlapY;\n        const face1Area = face1.width * face1.height;\n        if (overlapArea > face1Area * 0.5) {\n          // More than 50% overlap\n          if (face2.confidence > face1.confidence) {\n            keep = false;\n            break;\n          }\n        }\n      }\n      if (keep) {\n        filteredFaces.push(face1);\n      }\n    }\n\n    // Determine if looking away based on face position and quality\n    let lookingAway = false;\n    if (filteredFaces.length === 1) {\n      const face = filteredFaces[0];\n      const centerX = canvas.width / 2;\n      const centerY = canvas.height / 2;\n      const faceCenter = {\n        x: face.x + face.width / 2,\n        y: face.y + face.height / 2\n      };\n\n      // Check if face is too far from center or confidence is too low\n      const distanceFromCenter = Math.sqrt(Math.pow(faceCenter.x - centerX, 2) + Math.pow(faceCenter.y - centerY, 2));\n      if (distanceFromCenter > Math.min(canvas.width, canvas.height) * 0.25 || face.confidence < 0.2) {\n        lookingAway = true;\n      }\n    }\n    return {\n      faces: filteredFaces,\n      lookingAway\n    };\n  }, []);\n  const checkFaceDetection = useCallback(() => {\n    if (!videoRef.current || !canvasRef.current) return;\n    const result = detectFaces(videoRef.current, canvasRef.current);\n    const currentTime = Date.now();\n    if (result.faces && result.faces.length > 0) {\n      lastFaceDetectedRef.current = currentTime;\n\n      // Clear no face timer\n      if (noFaceTimerRef.current) {\n        clearTimeout(noFaceTimerRef.current);\n        noFaceTimerRef.current = null;\n      }\n\n      // Check for multiple faces\n      if (result.faces.length > 1) {\n        onEvent('Multiple faces detected - Suspicious activity', 'suspicious');\n      }\n\n      // Check if looking away\n      if (result.lookingAway) {\n        if (currentTime - lastLookingAwayRef.current > 5000) {\n          // 5 seconds\n          onEvent('Candidate looking away from camera for more than 5 seconds', 'warning');\n          lastLookingAwayRef.current = currentTime;\n        }\n      } else {\n        lastLookingAwayRef.current = currentTime;\n        // Clear looking away timer\n        if (lookingAwayTimerRef.current) {\n          clearTimeout(lookingAwayTimerRef.current);\n          lookingAwayTimerRef.current = null;\n        }\n      }\n    } else {\n      // No face detected\n      if (currentTime - lastFaceDetectedRef.current > 10000) {\n        // 10 seconds\n        if (!noFaceTimerRef.current) {\n          noFaceTimerRef.current = setTimeout(() => {\n            onEvent('No face detected for more than 10 seconds', 'warning');\n            noFaceTimerRef.current = null;\n          }, 1000);\n        }\n      }\n    }\n  }, [detectFaces, onEvent]);\n  useEffect(() => {\n    const interval = setInterval(checkFaceDetection, 1000); // Check every second\n\n    return () => {\n      clearInterval(interval);\n      if (noFaceTimerRef.current) {\n        clearTimeout(noFaceTimerRef.current);\n      }\n      if (lookingAwayTimerRef.current) {\n        clearTimeout(lookingAwayTimerRef.current);\n      }\n    };\n  }, [checkFaceDetection]);\n  useEffect(() => {\n    onEvent('Face detection monitoring started', 'info');\n    return () => {\n      onEvent('Face detection monitoring stopped', 'info');\n    };\n  }, [onEvent]);\n  return null; // This component doesn't render anything visible\n};\n_s(FaceDetection, \"0DlpZRnbT2N2tQS4tRkeQeaW4OM=\");\n_c = FaceDetection;\nexport default FaceDetection;\nvar _c;\n$RefreshReg$(_c, \"FaceDetection\");","map":{"version":3,"names":["useEffect","useRef","useCallback","FaceDetection","videoRef","canvasRef","onEvent","_s","faceDetectionRef","lastFaceDetectedRef","Date","now","lastLookingAwayRef","noFaceTimerRef","lookingAwayTimerRef","detectFaces","video","canvas","videoWidth","videoHeight","faces","lookingAway","ctx","getContext","width","height","drawImage","imageData","getImageData","data","gridSize","skinRegions","blockY","blockX","skinPixels","totalPixels","avgBrightness","y","x","index","r","g","b","brightness","Math","max","min","abs","skinRatio","push","faceRegions","used","Set","i","length","has","region","group","add","j","other","distance","sqrt","pow","minX","map","maxX","minY","maxY","avgSkinRatio","reduce","sum","confidence","regions","filteredFaces","face1","keep","face2","overlapX","overlapY","overlapArea","face1Area","face","centerX","centerY","faceCenter","distanceFromCenter","checkFaceDetection","current","result","currentTime","clearTimeout","setTimeout","interval","setInterval","clearInterval","_c","$RefreshReg$"],"sources":["C:/Users/nikhi/OneDrive/Desktop/Tutedude SDE Assignment/interview-proctoring-system/src/components/FaceDetection.js"],"sourcesContent":["import { useEffect, useRef, useCallback } from 'react';\r\n\r\nconst FaceDetection = ({ videoRef, canvasRef, onEvent }) => {\r\n  const faceDetectionRef = useRef(null);\r\n  const lastFaceDetectedRef = useRef(Date.now());\r\n  const lastLookingAwayRef = useRef(Date.now());\r\n  const noFaceTimerRef = useRef(null);\r\n  const lookingAwayTimerRef = useRef(null);\r\n\r\n  // Simple face detection fallback using basic computer vision principles\r\n  const detectFaces = useCallback((video, canvas) => {\r\n    if (!video || !canvas || video.videoWidth === 0 || video.videoHeight === 0) {\r\n      return { faces: [], lookingAway: false };\r\n    }\r\n\r\n    const ctx = canvas.getContext('2d');\r\n    canvas.width = video.videoWidth;\r\n    canvas.height = video.videoHeight;\r\n    \r\n    // Draw video frame to canvas\r\n    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);\r\n    \r\n    // Get image data\r\n    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\r\n    const data = imageData.data;\r\n    \r\n    const faces = [];\r\n    const gridSize = 32; // Divide image into 32x32 pixel blocks\r\n    const skinRegions = [];\r\n    \r\n    // Scan the image in blocks to find skin-colored regions\r\n    for (let blockY = 0; blockY < canvas.height - gridSize; blockY += gridSize) {\r\n      for (let blockX = 0; blockX < canvas.width - gridSize; blockX += gridSize) {\r\n        let skinPixels = 0;\r\n        let totalPixels = 0;\r\n        let avgBrightness = 0;\r\n        \r\n        // Check each pixel in this block\r\n        for (let y = blockY; y < blockY + gridSize; y += 2) {\r\n          for (let x = blockX; x < blockX + gridSize; x += 2) {\r\n            const index = (y * canvas.width + x) * 4;\r\n            const r = data[index];\r\n            const g = data[index + 1];\r\n            const b = data[index + 2];\r\n            \r\n            const brightness = (r + g + b) / 3;\r\n            avgBrightness += brightness;\r\n            \r\n            // Improved skin color detection\r\n            if (r > 95 && g > 40 && b > 20 && \r\n                Math.max(r, g, b) - Math.min(r, g, b) > 15 &&\r\n                Math.abs(r - g) > 15 && r > g && r > b &&\r\n                r < 255 && g < 255 && b < 255) { // Avoid oversaturated pixels\r\n              skinPixels++;\r\n            }\r\n            totalPixels++;\r\n          }\r\n        }\r\n        \r\n        const skinRatio = skinPixels / totalPixels;\r\n        avgBrightness /= totalPixels;\r\n        \r\n        // If this block has significant skin content, it might be a face region\r\n        if (skinRatio > 0.15 && avgBrightness > 60 && avgBrightness < 200) {\r\n          skinRegions.push({\r\n            x: blockX,\r\n            y: blockY,\r\n            skinRatio: skinRatio,\r\n            brightness: avgBrightness\r\n          });\r\n        }\r\n      }\r\n    }\r\n    \r\n    // Group nearby skin regions to form face candidates\r\n    const faceRegions = [];\r\n    const used = new Set();\r\n    \r\n    for (let i = 0; i < skinRegions.length; i++) {\r\n      if (used.has(i)) continue;\r\n      \r\n      const region = skinRegions[i];\r\n      const group = [region];\r\n      used.add(i);\r\n      \r\n      // Find nearby regions\r\n      for (let j = i + 1; j < skinRegions.length; j++) {\r\n        if (used.has(j)) continue;\r\n        \r\n        const other = skinRegions[j];\r\n        const distance = Math.sqrt(\r\n          Math.pow(region.x - other.x, 2) + \r\n          Math.pow(region.y - other.y, 2)\r\n        );\r\n        \r\n        // If regions are close enough, group them\r\n        if (distance < gridSize * 3) {\r\n          group.push(other);\r\n          used.add(j);\r\n        }\r\n      }\r\n      \r\n      // If group has enough regions, consider it a face\r\n      if (group.length >= 3) {\r\n        const minX = Math.min(...group.map(r => r.x));\r\n        const maxX = Math.max(...group.map(r => r.x)) + gridSize;\r\n        const minY = Math.min(...group.map(r => r.y));\r\n        const maxY = Math.max(...group.map(r => r.y)) + gridSize;\r\n        \r\n        const avgSkinRatio = group.reduce((sum, r) => sum + r.skinRatio, 0) / group.length;\r\n        \r\n        faceRegions.push({\r\n          x: minX,\r\n          y: minY,\r\n          width: maxX - minX,\r\n          height: maxY - minY,\r\n          confidence: avgSkinRatio,\r\n          regions: group.length\r\n        });\r\n      }\r\n    }\r\n    \r\n    // Filter out overlapping regions (keep the one with higher confidence)\r\n    const filteredFaces = [];\r\n    for (let i = 0; i < faceRegions.length; i++) {\r\n      const face1 = faceRegions[i];\r\n      let keep = true;\r\n      \r\n      for (let j = 0; j < faceRegions.length; j++) {\r\n        if (i === j) continue;\r\n        \r\n        const face2 = faceRegions[j];\r\n        \r\n        // Check for significant overlap\r\n        const overlapX = Math.max(0, Math.min(face1.x + face1.width, face2.x + face2.width) - Math.max(face1.x, face2.x));\r\n        const overlapY = Math.max(0, Math.min(face1.y + face1.height, face2.y + face2.height) - Math.max(face1.y, face2.y));\r\n        const overlapArea = overlapX * overlapY;\r\n        const face1Area = face1.width * face1.height;\r\n        \r\n        if (overlapArea > face1Area * 0.5) { // More than 50% overlap\r\n          if (face2.confidence > face1.confidence) {\r\n            keep = false;\r\n            break;\r\n          }\r\n        }\r\n      }\r\n      \r\n      if (keep) {\r\n        filteredFaces.push(face1);\r\n      }\r\n    }\r\n    \r\n    // Determine if looking away based on face position and quality\r\n    let lookingAway = false;\r\n    if (filteredFaces.length === 1) {\r\n      const face = filteredFaces[0];\r\n      const centerX = canvas.width / 2;\r\n      const centerY = canvas.height / 2;\r\n      const faceCenter = {\r\n        x: face.x + face.width / 2,\r\n        y: face.y + face.height / 2\r\n      };\r\n      \r\n      // Check if face is too far from center or confidence is too low\r\n      const distanceFromCenter = Math.sqrt(\r\n        Math.pow(faceCenter.x - centerX, 2) + \r\n        Math.pow(faceCenter.y - centerY, 2)\r\n      );\r\n      \r\n      if (distanceFromCenter > Math.min(canvas.width, canvas.height) * 0.25 || \r\n          face.confidence < 0.2) {\r\n        lookingAway = true;\r\n      }\r\n    }\r\n    \r\n    return { faces: filteredFaces, lookingAway };\r\n  }, []);\r\n\r\n  const checkFaceDetection = useCallback(() => {\r\n    if (!videoRef.current || !canvasRef.current) return;\r\n\r\n    const result = detectFaces(videoRef.current, canvasRef.current);\r\n    const currentTime = Date.now();\r\n\r\n    if (result.faces && result.faces.length > 0) {\r\n      lastFaceDetectedRef.current = currentTime;\r\n      \r\n      // Clear no face timer\r\n      if (noFaceTimerRef.current) {\r\n        clearTimeout(noFaceTimerRef.current);\r\n        noFaceTimerRef.current = null;\r\n      }\r\n\r\n      // Check for multiple faces\r\n      if (result.faces.length > 1) {\r\n        onEvent('Multiple faces detected - Suspicious activity', 'suspicious');\r\n      }\r\n\r\n      // Check if looking away\r\n      if (result.lookingAway) {\r\n        if (currentTime - lastLookingAwayRef.current > 5000) { // 5 seconds\r\n          onEvent('Candidate looking away from camera for more than 5 seconds', 'warning');\r\n          lastLookingAwayRef.current = currentTime;\r\n        }\r\n      } else {\r\n        lastLookingAwayRef.current = currentTime;\r\n        // Clear looking away timer\r\n        if (lookingAwayTimerRef.current) {\r\n          clearTimeout(lookingAwayTimerRef.current);\r\n          lookingAwayTimerRef.current = null;\r\n        }\r\n      }\r\n    } else {\r\n      // No face detected\r\n      if (currentTime - lastFaceDetectedRef.current > 10000) { // 10 seconds\r\n        if (!noFaceTimerRef.current) {\r\n          noFaceTimerRef.current = setTimeout(() => {\r\n            onEvent('No face detected for more than 10 seconds', 'warning');\r\n            noFaceTimerRef.current = null;\r\n          }, 1000);\r\n        }\r\n      }\r\n    }\r\n  }, [detectFaces, onEvent]);\r\n\r\n  useEffect(() => {\r\n    const interval = setInterval(checkFaceDetection, 1000); // Check every second\r\n    \r\n    return () => {\r\n      clearInterval(interval);\r\n      if (noFaceTimerRef.current) {\r\n        clearTimeout(noFaceTimerRef.current);\r\n      }\r\n      if (lookingAwayTimerRef.current) {\r\n        clearTimeout(lookingAwayTimerRef.current);\r\n      }\r\n    };\r\n  }, [checkFaceDetection]);\r\n\r\n  useEffect(() => {\r\n    onEvent('Face detection monitoring started', 'info');\r\n    \r\n    return () => {\r\n      onEvent('Face detection monitoring stopped', 'info');\r\n    };\r\n  }, [onEvent]);\r\n\r\n  return null; // This component doesn't render anything visible\r\n};\r\n\r\nexport default FaceDetection;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}